# Introduction

Lua is a scripting language often used in game engines. It is somewhat similar
to Python, but less advanced. One of the more interesting features it supports
is coroutines. Coroutines are similar to threads in the sense that they each
have their own execution context. They can run separately from each other, but
unlike threads, coroutines cannot run in parallel. Coroutines must be explicitly
resumed in order for them to run, and once they run, they must explicitly yield
to let the caller run again. Every time a resume or yield happens, data can be
passed along, which allows coroutines to communicate with each other.

In this article, we're going to define structural operational semantics for
coroutines in Lua. We'll restrict ourselves to a small subset of Lua in order to
focus on the concept of coroutines. Before we move on to the theory, let's have
a look at an example of Lua code using coroutines.

## Example code

import(example.tex)

# Syntax

syntax()

Most part of this syntax is very similar to the syntax of While, apart of some slight changes in keywords. e.g. "while $<expr>$ do $<block>$ end" instead of "while b do S" where b is an expression and S is a block. However, three relatively big things are different:

First of all, Lua doesn't have strong typing, while While does. This means that we do not know what the type of an expression is, until we've fully evaluated the expression. In our example, this leads to the b in While being an $<expr>$ in our model of Lua.

Second, Lua's syntactic structure consists of "blocks" instead of While's "statements". This, for instance, allows Lua to have an arbitrary number of semicolons in between statements. Primairly, this structure guarentees that the "return <var>" is at the end of a block. In our example, this leads to S in While being a $<block>$ in our model of Lua.

Lastly, we have added syntax to model coroutines. This leads to the existence of $<cowrap>$ and $<coyield>$.\\

[TODO: This is a wacky piece of explanation, please improve]
One may wonder why $<cowrap>$ and $<coyield>$ are statements instead of expressions. This is due to expressions having no side effects, this means that they only influence the single variable they are assigned to. Coroutines however, do not only change the returning value they are assigned to, but they also influence their own state/syntaxblock, which influences the future calls of the coroutine. If coroutines would be modeled as expressions, they would not be able to influence their own context, meaning that coroutines need to be statements.

# Semantics

## Values

% We define the usual boolean operations on false() and true()

## State

\[L(v) = {v | v = Var}\]

L(v) is a set with local variables. It will contain all our normal variables, these are nil, bools and numbers.

\[G(v) = {v | v = Var}\]

G(v) is a set with global variables. It will contain all the coroutinetuples.

\[ref_N = Ref\]

ref_N is the next free referencevalue. These will be used to identify coroutines.

\[\text{s} =  (\langle \text{var} \rangle \to \text{Val} \cup \text{Ref, Ref} \to \text{Val, Ref})\]

The state s is a tuple that contains the locals, globals and the next free referencenumber.
References are not natural numbers.

\[n(Ref) = \{ n(ref)_n | n \in \mathbb{N} \}\]

Nil is the set consisting of the nil element.

\[n(Nil) = \{ nil() \}\]

\[new() = (fn(x, nil()), fn(x, nil()), n(ref)_0)\]

new represents a fresh state with no bindings.

\[get((L, G, n(ref)_N), v) = L(v)\]

The get-function takes a state and a variablename and looks it up in the collection of locals.

\[coget((L, G, n(ref)_N), v) = G(L(v))\] % aanname: L(v) is een Ref

Gets the current state of a certain coroutine. For this, L(v) must be a Ref. Note that the global memory of the coroutine is inaccessable to other functions once this tuple is assigned to a variable.

\[merge((L_1, G_1, n(ref)_{N_1}), (L_2, G_2, n(ref)_{N_2})) =
(L_1, G_2, n(ref)_{n(max)(N_1, N_2)})\]

Merge combines two states. It takes the locals of the first state and the
globals of the second state. Lastly, it takes the maximum of the two reference
numbers, to ensure that this number isn't used as identifier yet.

\[let((L, G, n(ref)_N), v, x) = (fn(v', x, v = v', L(v')), G, n(ref)_N)\]

The let-function assigns a value x to a variable v in the set of locals of the
given state.

\[set((L, G, n(ref)_N), v, x) = (L, fn(r, x, L(v) = r, G(r)), n(ref)_N)\]

The set-function assigns a value x to a variable v in the set of globals of the
given state.

\[def((L, G, n(ref)_N), v, x) = (fn(v', n(ref)_N, v' = v, L(v')),
fn(r, x, r = n(ref)_N, G(r)), n(ref)_{N+1})\]

Def saves a coroutine in the current state. For this, it creates a reference
with variablename v and value $n(ref)_N$ to the coroutine in the set of locals.
It also saves the coroutine x in the set of globals with the reference
$n(ref)_N$. Lastly, it heightens up the next free referencevalue by one. The
coroutine is now saved within the set of globals with a unique referencevalue
and can be accessed by looking up this referencevalue in the set of locals.

## Expressions

\[eval(lambda(a, B), s) = (s, a, B)\]

## Simple rules

semantics(empty)

semantics(comp_1)
semantics(comp_2)

semantics(ass)

semantics(if_true)
semantics(if_false)

semantics(while)

## Function rules

semantics(call_ret)
semantics(call_nil)

## Coroutine rules

semantics(wrap)

The wrap-rule binds a function to a coroutine. The function itself will not be executed yet.\\

The resume rule continues a coroutine. The index $_O$ refers to the outside of the coroutine, while the index $_I$ refers to the inside of the coroutine. 

A new state is created, $s_I'$, consisting of the locals of $s_I$, being the local variables that the coroutine had the last time it got wrapped/yielded, and the globals of $s_O$. The rule then takes the argument $a_O$ and sets the variable $r_I$ in $s_I'$ to it. Next, the syntaxblock $B_I$ of the coroutine is executed with $s_I'$ as it's state.

Then, after a certain amount of steps later, there are three cases of syntax that can be encountered to end the resume and switch back to the outside piece of code:
semantics(resume_yield)

Case 1: a yield is encountered.

A new state $s_O'$ is formed with the locals of the old $s_O$ and the globals of current state $s_I''$. It also updates the value of the coroutine $c$. It does so by giving it the update state $s_I''$, the new variable that needs to be initialised $r_I'$ and the updated block of syntax $B_I'$ respectively. Lastly, it gives the outside of the coroutine his returnargument $a_I$, to which $r_O$ will be bound in $s_O'$. After updating the state, the old syntaxblock $B_O$ is run with this updated state $s_O'$.
semantics(resume_ret)

Case 2: a return is encountered.

Again, a new state $s_O'$ is formed by taking the locals of the old $s_O$ and the globals of $s_I''$. It also updates the value of the coroutine $c$. However, this time the coroutine has ended, so $c$ gets updated to nil(). This way, the next time $c$ gets called, $c$ can't be unpacked into the tuple ($s_I$, $r_I$, $B_I$) and the resume rules wil not patternmatch, resulting in an error. Lastly, it gives the outside of the coroutine his returnargument $a_I$, to which $r_O$ will be bound in $s_O'$. After updating the state, the old syntaxblock $B_O$ is run with this updated state $s_O'$.
semantics(resume_nil)

Case 3: $B_I$ ends in a final state $s_I''$

Like the other two cases, $s_O'$ consists of the locals of the original $s_O$ and the globals of $s_I''$. Then, we update the coroutine $c$ to nil(). Lastly, we have nothing to return, so we set $r_O$ to nil().

# Analysis
